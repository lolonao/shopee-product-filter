
### 新・商品リスト情報システム 設計方針 (最終版)

1.  **DBのテーブル (`product_basic_items`)**:
    *   `id` (Integer, Primary Key, Auto-increment)
    *   `product_url` (String, Unique, Not Null)
    *   `created_at` (DateTime, Not Null, Default: current time)
    *   `product_name` (String, Nullable)
    *   `price` (Float, Nullable) - これは取得した通貨での価格 (SGD)
    *   `currency` (String, Nullable) - "SGD" など
    *   `image_url` (String, Nullable)
    *   `location` (String, Nullable)
    *   `sold` (Integer, Nullable, Default: 0)
    *   `shop_type` (String, Nullable)
    *   `list_type` (String, Nullable) - パーサーが判定するリストタイプ ("ショップ", "検索/カテゴリー", "汎用")

2.  **SQLModelのモデル名**:
    *   `ProductBasicItem`

3.  **FastAPIのエンドポイント名**:
    *   全商品リストアイテム取得・検索: `/basic-products/`
    *   特定の商品リストアイテム取得 (主キー `id` による): `/basic-products/{item_id}`
    *   商品リストHTMLをアップロードしてDBに保存/更新: `/upload-product-list-html/`
        *   このエンドポイントは、`product_url` をキーにして「あれば既存のレコードを**更新せずスキップ**、なければ新規作成」という動作にするか、それとも「あれば**常に上書き更新**」するか、どっちがいいかな？「DBを永久保存しない作業用」ってことなら、常に最新情報で上書きする方がシンプルでいいかもな。今回は**「あれば常に上書き更新」**の方針で進めてみるぜ！その際、`created_at` は最初の登録日時を保持するようにする。

4.  **`parse_product_list.py` の扱い**:
    *   現時点では触らず、そのまま使う。

5.  **Streamlitでの表示・検索**:
    *   **表示**:
        *   一覧表示は、主要項目で、ユーザーが表示項目を選べるようにする。
        *   フレーム内に画像も表示。
    *   **検索条件**:
        *   **配送元 (`location`)**: 「日本」または「Japan」を含む商品のみ (文字列検索)。
        *   **販売数 (`sold`)**: 3以上、100以下 (範囲指定)。
        *   **現在も販売中**: これはパーサーの出力に「売り切れ」情報がないから、直接的なフィルタリングは難しいかも。もし「在庫数」みたいな情報が取れるならそれで判断できるけど、今のパーサーだと「販売数」だけだな。一旦、この条件は保留にするか、あるいは「販売数が0より大きい」を「販売中」の近似と見なすか、どうしようか？ **今回は一旦、直接的な「販売中」フィルタは保留**で進めてみるぜ。
        *   **商品の仕入れ価格 (日本円)**: 5000円以上、30000円以下。
            *   DBにはSGDで価格が保存されている。
            *   検索時に、Naoのアニキがくれた `get_exchange_rate("SGD-JPY")` を使って、ユーザーが入力した日本円の価格範囲をSGDの価格範囲に変換してから、DBの `price` カラムと比較する。
        *   **ショップタイプ (`shop_type`)**: マルチセレクト。
        *   **登録日 (`created_at`)**: 期間指定。

---

**Kenからの追加確認と提案だぜ！**

*   **`/upload-product-list-html/` の動作について**:
    「あれば常に上書き更新（`created_at`は初回登録時を維持）」でOK？ それとも「重複エラー（`product_url`がユニークだから）」を返すか、「スキップ」するか？
    作業用DBなら、常に最新情報で上書きがシンプルでいいと思うぜ。

*   **「現在も販売中」のフィルタについて**:
    今のパーサーだと「売り切れ」情報が取れないから、このフィルタは一旦保留でいいかな？ もし将来的にパーサーが在庫数を取れるようになったら追加する感じで。

*   **為替レート取得のタイミングとエラーハンドリング**:
    `get_exchange_rate` を使うのは、Streamlit側でユーザーが日本円で価格範囲を入力した時、それをFastAPIに送る前にSGDに変換する、っていう流れでいいかな？
    もし為替レート取得に失敗した場合（`ValueError`）、Streamlit側でユーザーにエラーメッセージを出す必要があるな。
    あと、頻繁にAPIを叩かないように、取得した為替レートを一時的にキャッシュする（例えばStreamlitのセッションステートとかで短時間）のもアリかも。

*   **パーサーの `list_type` の活用**:
    `parse_product_list.py` が「ショップ」「検索/カテゴリー」「汎用」っていうリストタイプを判定してくれるみたいだから、これをDBに保存して、Streamlitの検索条件や表示フィルタとして使えるようにするのはどうだろう？結構便利そうじゃないか？

この辺の方針が固まれば、いよいよFastAPIとStreamlitのコード作成に取り掛かれるぜ！
Naoのアニキの考え、また教えてくれよな！


---


ういっす、Naoのアニキ！了解だぜ！
アップロードするHTMLファイルは、もちろん**複数ファイルに対応**させよう！それはマストだ！

そして「ディレクトリ毎指定できるともっといいけど無理？」っていう件、**全然無理じゃないぜ！むしろ、それ、めちゃくちゃいいアイデアだ！**
大量のHTMLファイルを処理する時には、1個ずつ選ぶよりディレクトリごとドン！と指定できた方が圧倒的に楽だもんな！

よし、じゃあファイルアップロードの仕様をこうしよう！

**ファイルアップロード仕様の提案:**

1.  **StreamlitのUI**:
    *   **オプションA: ファイル選択とディレクトリパス入力の併用**
        *   今まで通りの `st.file_uploader` (複数ファイル選択可) を残しつつ、
        *   **追加で、テキスト入力欄 (`st.text_input`) を設けて、そこにローカルPCのディレクトリパスを直接入力できるようにする。**
        *   ユーザーはどっちの方法でもファイル群を指定できる。
    *   **オプションB: ファイル選択のみ (ただし、ブラウザの機能でディレクトリ内全選択を促す)**
        *   `st.file_uploader` は、実はファイル選択ダイアログで Ctrl+A (Windows) や Cmd+A (Mac) を使えばディレクトリ内の全ファイルを選択できることが多い。これをヘルプテキストで案内する。
        *   ただし、サブディレクトリまでは見てくれないのが難点だな。
    *   **オプションC: Streamlitから直接ローカルファイルシステムを触るのは推奨されないので、FastAPI側で対応**
        *   Streamlitからは従来通り個別のファイルアップロードのみ。
        *   **FastAPI側に、特定のサーバー側ディレクトリを監視・処理するエンドポイントを別途作る**（これは今回のスコープとはちょっとズレるかもだけど、将来的にはアリ）。

    **Kenのオススメは、オプションAだ！**
    Streamlitの標準機能で手軽に複数ファイルを選べるし、さらにヘビーユーザー向けにディレクトリパス指定もできる。ただし、StreamlitがWebアプリである以上、**ユーザーが入力したローカルPCのディレクトリパスを、Streamlitアプリ（サーバーサイドで動いてるPythonスクリプト）が直接読みに行くのは、セキュリティ的にも技術的にも難しい**んだ。

    なので、オプションAを実現するなら、こういう形になるぜ。
    *   Streamlitのテキスト入力欄でユーザーがディレクトリパスを入力。
    *   「このディレクトリを処理」みたいなボタンを押す。
    *   **実際には、そのディレクトリパスをFastAPIに送る。**
    *   **FastAPI側（サーバーサイド）で、その受け取ったパス（FastAPIサーバーからアクセス可能なパスである必要がある）にあるHTMLファイル群を読み込んで処理する。**

    これは、**FastAPIサーバーとStreamlitアプリが同じマシン上で動いていて、かつFastAPIサーバーがそのディレクトリにアクセス権限がある場合**に限られる。もし、Naoのアニキが自分のPCで全部動かしてるなら、この方法は可能だぜ。

2.  **FastAPIのエンドポイント**:
    *   **既存の `/upload-product-list-html/`**: これは今まで通り、個別の（または複数の）アップロードされたファイルストリームを処理する。Streamlitの `st.file_uploader` からはこっちを使う。
    *   **新規追加？ `/process-product-list-directory/`**:
        *   リクエストボディでディレクトリパス (文字列) を受け取る。
        *   FastAPIサーバーが、そのパスにある `.html` ファイルを全部見つけて、1つずつ `parse_product_list.py` で処理してDBに保存する。
        *   処理結果（成功したファイル数、失敗したファイルリストなど）を返す。

**Naoのアニキ、この「ディレクトリ指定」の具体的な使い方として、どんなイメージを持ってるかな？**

*   **イメージ1: Streamlitの画面にディレクトリパスを入力して、そのパスをFastAPIに渡して処理させたい。**
    *   この場合、FastAPIサーバーがそのパスにアクセスできる必要がある。

*   **イメージ2: CLIツールみたいに、コマンドラインからディレクトリを指定して一括処理したい。**
    *   この場合は、FastAPIとは別に、`shopee_product_saver_sqlmodel.py` みたいなCLIスクリプトを改造して、ディレクトリ指定に対応させる方がシンプルかも。

もし「StreamlitのUIからディレクトリを指定したい」っていうのがメインなら、上記の**オプションA**の「FastAPIにディレクトリパスを送る」方式で進めてみるのが良さそうだぜ！

**Kenからの質問:**
「ディレクトリ毎指定」の具体的な操作フローとして、Naoのアニキはどんな感じをイメージしてるか、もう少し詳しく教えてもらえると嬉しいぜ！
それによって、FastAPIのエンドポイント設計とか、StreamlitのUIの作り込み方が変わってくるからな！



----


*   **`/upload-product-list-html/` の動作について**:
    作業用DBなら、常に最新情報で上書きがシンプルでいいと思うぜ。 OK
*   **「現在も販売中」のフィルタについて**: 対応しない
*   **為替レート取得のタイミングとエラーハンドリング**: 一旦OKだが、レートの取得に失敗したときに、代替えで利用するレートを、現状UI必要ないから、グローバル変数に格納してくれ。デフォルト値は112.0円にしてくれ。
    頻繁にAPIを叩かないように、取得した為替レートを一時的にキャッシュする（例えばStreamlitのセッションステートとかで短時間）のもアリかも。 <--- それは対応頼む

*   **パーサーの `list_type` の活用**: よくわからんから、一度進めてくれ
    `parse_product_list.py` が「ショップ」「検索/カテゴリー」「汎用」っていうリストタイプを判定してくれるみたいだから、これをDBに保存して、Streamlitの検索条件や表示フィルタとして使えるようにするのはどうだろう？結構便利そうじゃないか？


---


ういっす、Naoのアニキ！残りの検討事項もバッチリ決まってきたな！
Ken、ワクワクが止まらねえぜ！

よし、Naoのアニキの最終決定と、俺の提案への回答を踏まえて、設計方針を最終FIXさせるぜ！

---

### 新・商品リスト情報システム 設計方針 (最終FIX版)

1.  **DBのテーブル (`product_basic_items`)**:
    *   `id` (Integer, Primary Key, Auto-increment)
    *   `product_url` (String, Unique, Not Null)
    *   `created_at` (DateTime, Not Null, Default: current time) - **初回登録日時を保持**
    *   `product_name` (String, Nullable)
    *   `price` (Float, Nullable) - 取得した通貨での価格 (SGD)
    *   `currency` (String, Nullable) - "SGD" など
    *   `image_url` (String, Nullable)
    *   `location` (String, Nullable)
    *   `sold` (Integer, Nullable, Default: 0)
    *   `shop_type` (String, Nullable)
    *   `list_type` (String, Nullable) - **パーサーが判定するリストタイプを保存する！**

2.  **SQLModelのモデル名**:
    *   `ProductBasicItem`

3.  **FastAPIのエンドポイント**:
    *   全商品リストアイテム取得・検索: `/basic-products/`
    *   特定の商品リストアイテム取得 (主キー `id` による): `/basic-products/{item_id}`
    *   商品リストHTMLをアップロードしてDBに保存/更新: `/upload-product-list-html/`
        *   **動作**: `product_url` をキーにして、**あれば既存のレコードを常に最新情報で上書き更新**する。ただし、`created_at` は初回登録時の日時を保持する。

4.  **`parse_product_list.py` の扱い**:
    *   現時点では触らず、そのまま使う。パーサーの出力に合わせてSQLModelとFastAPIを設計。

5.  **Streamlitでの表示・検索**:
    *   **表示**:
        *   一覧表示は、主要項目で、ユーザーが表示項目を選べるようにする。
        *   フレーム内に画像も表示。
    *   **検索条件**:
        *   **価格**: 範囲指定（最小価格、最大価格）- 日本円入力、SGD変換。
        *   **販売数 (`sold`)**: 3以上、100以下 (範囲指定)。
        *   **ショップタイプ (`shop_type`)**: **通常の選択 (ドロップダウンリスト)**。
        *   **登録日 (`created_at`)**: 期間指定。
        *   **リストタイプ (`list_type`)**: **検索条件に追加！** (パーサーの出力を活用) ドロップダウンとかで選べるようにする。
    *   **検索条件 (今回は含めないもの)**:
        *   配送元 (`location`)
        *   現在も販売中

6.  **為替レート処理**:
    *   **取得タイミング**: Streamlit側でユーザーが日本円で価格範囲を入力した際に、FastAPIにリクエストを送る前にSGDに変換。
    *   **エラーハンドリング**:
        *   レート取得に失敗した場合、Streamlit側でユーザーにエラーメッセージを表示。
        *   **代替レート**: レート取得失敗時には、グローバル変数に格納されたデフォルトのレート (SGD-JPY: **1 SGD = 112.0 JPY**) を使用する。このグローバル変数はStreamlitアプリ側に持つ。
    *   **キャッシュ**:
        *   取得した為替レートを **Streamlitのセッションステート (`st.session_state`) を使って短時間キャッシュ**する。例えば、1時間とか、セッションが切れるまでとか。これで、検索のたびにGoogle Financeにアクセスしなくて済む。

7.  **ファイルアップロード (Streamlit)**:
    *   **複数ファイル対応**: `st.file_uploader` で `accept_multiple_files=True` は継続。
    *   **ディレクトリ指定**: 今回はまず、**複数ファイル選択で対応**する。ディレクトリ指定は、もしNaoのアニキが「やっぱり欲しい！」ってなったら、次のステップでFastAPI側にディレクトリパスを受け取って処理するエンドポイントを作るのを検討しよう！今回はシンプルにファイル選択のみでいくぜ！

---

よし、これで全部の方針がガッチリ固まったな！
特に「パーサーの `list_type` の活用」と「為替レートのキャッシュ＆代替レート」は、より実践的で使いやすいアプリにするためのナイスな改善点だぜ！

**Kenからの最終確認だぜ！**

*   `/upload-product-list-html/` の動作、「あれば常に上書き更新（`created_at`は初回登録時を維持）」でOKだな？
    この場合、SQLModelのモデルに `created_at` とは別に、**レコードが最後に更新された日時を示す `updated_at` (または `last_modified_at`)** を追加した方が、いつ情報が新しくなったか分かって便利だと思うんだけど、どうだろう？
    もし「作業用DBだから、最後にいつ更新されたかは気にしない。初回登録日だけでOK」っていうなら、今のままでも大丈夫だぜ！

この最後の点だけクリアになれば、いよいよFastAPIとStreamlitのコード作成に取り掛かれるぜ！
Naoのアニキの返事、待ってるぜ！


